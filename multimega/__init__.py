"""
Interface for a multiaccount MEGA cloud service
"""

import re
import os
import glob
import getpass
import hashlib
import logging
import sqlite3
import zipfile
import datetime
import pandas
import pyminizip  # pylint: disable=E0401
import mega  # pylint: disable=E0401
from .interface import MegaInterface


def hash_file(path):
    """Return the size and the SHA256 fingerprint of a file"""
    sha = hashlib.sha256()
    content = b""
    with open(path, "rb") as file:
        content = file.read()
        sha.update(content)
    return sha.hexdigest(), len(content)


def preprocess(path, seed, pwd):
    """
    Compress a file or a directory into a ZIP archive, which in turn is stored
    and encrypted in another ZIP archive, to prevent reading filenames without
    the password.
    The archive name is determined by truncated the first 16 characters of the
    SHA256 hexadecimal digest of the destination argument.
    """
    sha = hashlib.sha256()
    sha.update(seed.encode("utf8"))
    dest = sha.hexdigest()[:16]
    tmp_path = dest + ".encrypted.zip"
    tmp = zipfile.ZipFile(tmp_path, "x", zipfile.ZIP_DEFLATED)
    if os.path.isfile(path):
        tmp.write(path, os.path.basename(path))
        logging.info("Adding %s", os.path.realpath(path))
    else:
        for filepath in glob.glob(os.path.join(path, "**", "*"), recursive=True):
            if os.path.isfile(filepath):
                tmp.write(filepath, arcname=os.path.relpath(filepath, path))
                logging.info("Adding %s", os.path.realpath(filepath))
    tmp.close()
    logging.info("Encrypting archive to %s", dest + ".zip")
    pyminizip.compress(tmp_path, "", dest + ".zip", pwd, 0)
    os.remove(tmp_path)
    return dest + ".zip"


def format_size(byte):
    """
    Format a byte size to string
    """
    kilobyte = byte / 1024
    megabyte = kilobyte / 1024
    gigabyte = megabyte / 1024
    def _format_size(amount, unit):
        if amount >= 10 or unit == "":
            return "%.0f%s" % (amount, unit)
        return "%.1f%s" % (amount, unit)
    if gigabyte >= 1:
        return _format_size(gigabyte, "G")
    if megabyte >= 1:
        return _format_size(megabyte, "M")
    if kilobyte >= 1:
        return _format_size(kilobyte, "K")
    return _format_size(byte, "")


def html(files, accounts):
    """
    Generate an HTML index file of the uploaded files
    """
    body_template = """
    <!DOCTYPE html>
    <html>
        <head>
            <title>Index of MultiMega</title>
            <meta name="viewport" content="width=device-width" />
            <meta charset="utf-8" />
        </head>
        <body>
            <h1>Index of MultiMega</h1>
            <table>
                <tr>
                    <th>Name</th>
                    <th>Uploaded</th>
                    <th>Size</th>
                    <th>SHA256</th>
                </tr>
                <tr><th colspan="5"><hr></th></tr>
                {rows}
                <tr><th colspan="5"><hr></th></tr>
            </table>
            <h2>Accounts</h2>
            <table>
                <tr>
                    <th>Login</th>
                    <th>Quota</th>
                    <th>Usage</th>
                    <th>Available</th>
                </tr>
                <tr><th colspan="5"><hr></th></tr>
                {account_rows}
                <tr><th colspan="5"><hr></th></tr>
            </table>
            <address>Generated by MultiMega 1.0 Cloud Interface</address>
        </body>
    </html>
    """
    row_template = """
    <tr>
        <td><a href="{link}">{filename}</a></td>
        <td align="right">{uploaded}</td>
        <td align="right">{size}</td>
        <td align="right">{fingerprint}</td>
    </tr>
    """
    account_row_template = """
    <tr>
        <td>{login}</td>
        <td align="right">{quota}</td>
        <td align="right">{usage}</td>
        <td align="right">{free}</td>
    </tr>
    """
    rows = ""
    for _, row in files.iterrows():
        rows += row_template.format(
            link=row["link"],
            filename=row["filename"],
            uploaded=row["upload_date"][:-3],
            size=format_size(row["size"]),
            password=row["password"],
            fingerprint=row["fingerprint"].upper()
        )
    account_rows = ""
    for _, row in accounts.iterrows():
        account_rows += account_row_template.format(
            login=row["login"],
            quota=format_size(row["quota"]),
            usage=str(int(100. * row["usage"] / row["quota"])) + "%",
            free=format_size(row["quota"] - row["usage"])
        )
    with open("index.html", "w") as file:
        file.write(re.sub("  +", "", body_template.format(
            rows=rows,
            account_rows=account_rows
        )))


class Operator:
    """Operator that executes the module's actions"""

    def __init__(self, path):
        self.path = path
        if not os.path.isfile(path):
            self._create()

    def _execute(self, query, *args):
        connection = sqlite3.connect(self.path)
        cursor = connection.cursor()
        cursor.execute(query, args)
        response = list(cursor.fetchall())
        connection.commit()
        connection.close()
        return response

    def _create(self):
        if os.path.isfile(self.path):
            logging.error("Could not create the database: it already exists.")
            return
        logging.info("Create database at %s", os.path.realpath(self.path))
        self._execute("""CREATE TABLE accounts (
            id integer NOT NULL PRIMARY KEY AUTOINCREMENT,
            login varchar(255) NOT NULL UNIQUE,
            password varchar(255) NOT NULL,
            quota integer unsigned NOT NULL CHECK (quota > 0),
            usage integer unsigned NOT NULL CHECK (usage >= 0)
        )""")
        self._execute("""CREATE TABLE files (
            id integer NOT NULL PRIMARY KEY AUTOINCREMENT,
            original varchar(255) NOT NULL UNIQUE,
            obfuscated varchar(255) NOT NULL UNIQUE,
            password varchar(255) NOT NULL,
            fingerprint varchar(64) NOT NULL,
            size integer unsigned NOT NULL CHECK (size >= 0)
        )""")
        self._execute("""CREATE TABLE uploads (
            id integer NOT NULL PRIMARY KEY AUTOINCREMENT,
            account_id integer NOT NULL REFERENCES accounts(id),
            file_id integer NOT NULL REFERENCES files(id),
            key varchar(8) NOT NULL UNIQUE,
            link varchar(255) NOT NULL UNIQUE,
            date_added datetime NOT NULL
        )""")

    def _find_account(self, login):
        response = self._execute("SELECT id FROM accounts WHERE login=?", login)
        if len(response) == 0:
            return None
        return response[0][0]

    def _find_fitting_account(self, size):
        response = self._execute(
            " ".join([
                "SELECT id, login, quota - usage AS free",
                "FROM accounts",
                "WHERE free > ?",
                "ORDER BY free LIMIT 1"
            ]),
            size
        )
        if len(response) == 0:
            logging.error("No account with enough free storage space found")
            return None
        logging.info("Selected account #%d<%s>", response[0][0], response[0][1])
        return response[0][0]

    def _find_file(self, name):
        response = self._execute("SELECT id FROM files WHERE original=?", name)
        if len(response) == 0:
            return None
        return response[0][0]

    def create_account(self):
        """Add an account to the database"""
        login = input("login> ")
        password = getpass.getpass("password> ")
        quota = int(input("quota (Gb)> "))
        mega_interface = mega.Mega()
        mega_client = mega_interface.login(login, password)
        storage_space = mega_client.get_storage_space()
        assert quota * (1024 ** 3) <= storage_space["total"]
        self._execute(
            " ".join([
                "INSERT INTO accounts(login, password, quota, usage)",
                "VALUES (?, ?, ?, ?)",
            ]),
            login,
            password,
            quota * (1024 ** 3),
            storage_space["used"]
        )

    def sync_account(self, login):
        """Synchronize the usage of a user"""
        account_id = self._find_account(login)
        if account_id is None:
            logging.error("Account %s not found", login)
            return
        password = self._execute(
            "SELECT password FROM accounts WHERE id=?",
            account_id
        )[0][0]
        uploads = set(map(lambda x: x[0], self._execute(" ".join([
            "SELECT files.obfuscated FROM files, uploads",
            "WHERE files.id = uploads.file_id",
            "AND uploads.account_id=?"
        ]), account_id)))
        mega_interface = mega.Mega()
        mega_client = mega_interface.login(login, password)
        for key, file in mega_client.get_files().items():
            if file["t"] != 0:
                continue
            if file["a"]["n"] not in uploads:
                mega_client.destroy(key)
        self._execute(
            "UPDATE accounts SET usage=? WHERE id=?",
            mega_client.get_storage_space()["used"],
            account_id
        )

    def _link_file_to_account(self, account_id, file_id, key, link, timestamp):
        usage = self._execute(
            "SELECT usage FROM accounts WHERE id=?",
            account_id
        )[0][0]
        size = self._execute(
            "SELECT size FROM files WHERE id=?",
            file_id
        )[0][0]
        self._execute(
            "UPDATE accounts SET usage=? WHERE id=?",
            usage + size,
            account_id
        )
        self._execute(
            " ".join([
                "INSERT INTO uploads(account_id, file_id, key, link, date_added)",
                "VALUES (?, ?, ?, ?, ?)",
            ]),
            account_id,
            file_id,
            key,
            link,
            datetime.datetime.fromtimestamp(timestamp)
        )

    def _get_client(self, account_id):
        login, password = self._execute(
            "SELECT login, password FROM accounts WHERE id=?",
            account_id
        )[0]
        client = MegaInterface()
        client.login(login, password)
        return client

    def _upload_file(self, path, account_id, file_id):
        logging.info("Uploading file %d to account %d", file_id, account_id)
        client = self._get_client(account_id)
        name = self._execute(
            "SELECT obfuscated FROM files WHERE id=?",
            file_id
        )[0][0]
        file = client.progress_upload(path, dest_filename=name)
        self._link_file_to_account(
            account_id,
            file_id,
            file["f"][0]["h"],
            client.get_upload_link(file),
            file["f"][0]["ts"]
        )

    def _find_upload(self, file_id):
        response = self._execute(
            "SELECT link FROM uploads WHERE file_id=?",
            file_id
        )
        if len(response) == 0:
            return None
        return response[0][0]

    def upload_file(self, path, name, password):
        """File upload routine"""
        file_id = self._find_file(name)
        if file_id is not None:
            if self._find_upload(file_id) is not None:
                logging.warning("File is already uploaded")
                return
            self._execute("DELETE FROM files WHERE id=?", file_id)
        obfuscated = preprocess(path, name, password)
        fingerprint, size = hash_file(obfuscated)
        self._execute(
            " ".join([
                "INSERT INTO files",
                "(original, obfuscated, password, fingerprint, size)",
                "VALUES (?, ?, ?, ?, ?)",
            ]),
            name,
            obfuscated,
            password,
            fingerprint,
            size
        )
        file_id = self._find_file(name)
        account_id = self._find_fitting_account(size)
        if account_id is None:
            return
        self._upload_file(obfuscated, account_id, file_id)
        os.remove(obfuscated)

    def list_files(self, export_format):
        """List all files that are uploaded"""
        data = self._execute(" ".join([
            "SELECT files.original, files.size, files.fingerprint,",
            "files.password, uploads.link, uploads.date_added",
            "FROM files, uploads",
            "WHERE files.id = uploads.file_id",
            "ORDER BY files.original"
        ]))
        dataframe = pandas.DataFrame(
            data,
            columns=["filename", "size", "fingerprint", "password", "link", "upload_date"]
        )
        if export_format == "txt":
            print(dataframe.to_string(index=False))
        elif export_format == "csv":
            print(dataframe.to_csv(index=False))
        elif export_format == "json":
            print(dataframe.to_json(orient="table", index=False))
        elif export_format == "html":
            html(dataframe, pandas.DataFrame(
                self._execute("SELECT id, login, quota, usage FROM accounts"),
                columns=["id", "login", "quota", "usage"]
            ))

    def list_accounts(self):
        """List all accounts"""
        data = self._execute("SELECT login, quota, usage FROM accounts")
        dataframe = pandas.DataFrame(
            data,
            columns=["login", "quota", "usage"]
        )
        print(dataframe.to_string(index=False))

    def delete_file(self, name):
        """Delete a file"""
        file_id = self._find_file(name)
        if file_id is None:
            logging.warning("File not found")
            return
        response = self._execute(
            "SELECT id, account_id FROM uploads WHERE file_id=?",
            file_id
        )
        if len(response) != 0:
            upload_id, account_id = response[0]
            login, password, key = self._execute(
                " ".join([
                    "SELECT accounts.login, accounts.password, uploads.key",
                    "FROM accounts, uploads",
                    "WHERE accounts.id = uploads.account_id AND uploads.id=?"
                ]),
                upload_id
            )[0]
            size = self._execute(
                "SELECT size FROM files WHERE id=?",
                file_id
            )[0][0]
            usage = self._execute(
                "SELECT usage FROM accounts WHERE id=?",
                account_id
            )[0][0]
            mega_interface = mega.Mega()
            mega_client = mega_interface.login(login, password)
            mega_client.destroy(key)
            self._execute(
                "DELETE FROM uploads WHERE id=?",
                upload_id
            )
            self._execute(
                "UPDATE accounts SET usage=? WHERE id=?",
                usage - size,
                account_id
            )
        self._execute("DELETE FROM files WHERE id=?", file_id)

    def find_file(self, name):
        """
        Find, if it exists, the account having the file whose original name is
        given, and store it as an upload.
        """
        file_id = self._find_file(name)
        if file_id is None:
            logging.error("File not found: %s", name)
            return
        obfuscated = self._execute(
            "SELECT obfuscated FROM files WHERE id=?",
            file_id
        )[0][0]
        for account_id in self._execute("SELECT id FROM accounts"):
            client = self._get_client(account_id[0])
            file = client.find(obfuscated)
            if file is None:
                continue
            logging.info("Linking file %s to account #%d", name, account_id[0])
            self._link_file_to_account(
                account_id[0],
                file_id,
                file[0],
                client.get_link(file),
                file[1]["ts"]
            )
            return
        logging.error("File %s not found", name)
